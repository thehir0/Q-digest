# Q-digest
Q-digest is a data structure used for compactly representing the frequency distribution of a set of integer values. Q-digest represents the data in tree-like structure where each node corresponds to a range of values and contains a count of the number of values falling in that range. The q-digest allows for the trade-off between space and accuracy by adjusting the compression parameter, which determines the maximum number of a buckets.
To construct the q-digest, we first create a leaf node for each integer value in the range [1,σ], where σ is the largest integer observed. We then merge adjacent leaf nodes pairwise to create level-1 nodes, and continue this process until we reach a single root node. At each level of the tree, we apply the COMPRESS algorithm if the nodes do not satisfy the conditions:
count(v) ≤ floor(n/k),
count(v) + count(vp) + count(vs) > floor(n/k)
The only exception to this property are the root and leaf nodes. If a leaf’s frequency is larger than floor(n/k) then too it belongs to the q-digest. And since there are no parent and sibling for root, its can violate property 2 and still belong to the q-digest[1]
To find the qth quantile from a q-digest, the nodes of the q-digest are sorted in increasing right endpoints, and the counts of the nodes are added in a post-order traversal until the sum becomes more than qn, at which point the maximum value of the current node is reported as the estimate of the quantile.
One limitation of the q-digest is that it loses detailed information about infrequent integers, which are grouped together into larger bins. However, it provides an accurate representation of the distribution for frequent integers, which are represented by smaller bins with low error. The compression parameter k determines the trade-off between accuracy and size, with larger values of k resulting in smaller digests with higher error.
[1] https://graphics.stanford.edu/courses/cs468-05-winter/Papers/Information_Aggregation/Suri_sensys04.pdf
